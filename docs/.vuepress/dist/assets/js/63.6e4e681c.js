(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{265:function(t,e,a){"use strict";a.r(e);var s=a(0),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"getting-started"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getting-started"}},[t._v("#")]),t._v(" Getting Started")]),t._v(" "),a("h2",{attrs:{id:"what-is-shader-park"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-shader-park"}},[t._v("#")]),t._v(" What is shader park?")]),t._v(" "),a("p",[t._v("It's a creative coding community that aims to take a niche area of graphics programming and make it accessible to new developers, while simplifying the creation process for experience graphics programmers.")]),t._v(" "),a("p",[t._v("The graphics technique used in Shader Park is called Signed Distance Fields. If you're new to them, that's great!\nThis community is here to teach you how they work and get you creating your own artwork quickly.")]),t._v(" "),a("iframe",{staticStyle:{float:"left"},attrs:{width:"50%",height:"450px",src:"https://shader-park.appspot.com/sculpture/-LSgHohvTH80MAgJbbPy?hideeditor=true&hidepedestal=true&embed=true&clickenabled=false",frameborder:"0"}}),t._v(" "),a("iframe",{staticStyle:{float:"left"},attrs:{width:"50%",height:"450px",src:"https://shader-park.appspot.com/sculpture/-LPOucSRaaSOIEF9W5Qs?hideeditor=true&hidepedestal=true&embed=true&clickenabled=false",frameborder:"0"}}),t._v(" "),a("iframe",{staticStyle:{float:"left"},attrs:{width:"50%",height:"450px",src:"https://shader-park.appspot.com/sculpture/-LRNqUDSccinZfco4bOy?hideeditor=true&hidepedestal=true&embed=true&clickenabled=false",frameborder:"0"}}),t._v(" "),a("iframe",{staticStyle:{float:"left"},attrs:{width:"50%",height:"450px",src:"https://shader-park.appspot.com/sculpture/-LQLGa1s1XZx3cjMKJuD?hideeditor=true&hidepedestal=true&embed=true&clickenabled=false",frameborder:"0"}}),t._v(" "),a("h2",{attrs:{id:"what-language-is-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-language-is-this"}},[t._v("#")]),t._v(" What language is this?")]),t._v(" "),a("p",[t._v("The code is written in GLSL which runs directly the graphics card. Unlike more commonly taught languages, the graphics card runs operations in parallel, so code specific to graphics programming can run very efficiently.\nShader park provides a number of helper functions that are available under "),a("a",{attrs:{href:"https://shader-park.appspot.com/references",target:"_blank",rel:"noopener noreferrer"}},[t._v("references"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("p",[t._v("If you're new to GLSL check out our guide "),a("a",{attrs:{href:"#glsl"}},[t._v("here")])]),t._v(" "),a("h2",{attrs:{id:"creating-your-first-sculpture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-your-first-sculpture"}},[t._v("#")]),t._v(" Creating your first sculpture")]),t._v(" "),a("iframe",{attrs:{width:"100%",height:"450px",src:"http://shader-park.appspot.com/sculpture/-LM-Nx6cvMmlbdKKiB64?example=true&embed=true",frameborder:"0"}}),t._v(" "),a("p",[t._v("In "),a("strong",[t._v("scene")]),t._v(" we define the shape of the object that we want to create.\nOne thing to note is that the code written in scene is run on every pixel.")]),t._v(" "),a("p",[t._v("Notice that we return a float out of "),a("strong",[t._v("scene")]),t._v('. In order to create a shape we need to return the shortest distance to the shape where positive values are outside the shape, negative values are inside, and 0 is at the surface of the shape. The positive, or negative part is the "Signed" in Signed Distance Field.')]),t._v(" "),a("h2",{attrs:{id:"creating-our-own-signed-distance-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-our-own-signed-distance-function"}},[t._v("#")]),t._v(" Creating our own Signed Distance Function")]),t._v(" "),a("p",[t._v("In this example we'll write the sphere function from scratch.")]),t._v(" "),a("p",[t._v("If you're new to creating graphics on a GPU you can imagine the scene function is run with "),a("strong",[t._v("p")]),t._v(" (the current pixel position) passed in with every value from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0)")]),t._v(" "),a("div",{staticClass:"language-glsl extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-glsl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Note this is just a mental model")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.001")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.001")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" z"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.001")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" distanceToObject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("scene")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("It's not actually set up like this because the GPU will run this process in parallel, which makes it incredibly fast.")]),t._v(" "),a("p",[t._v("Now imagine we've paused part way through the loop and "),a("strong",[t._v("p")]),t._v(" happens to be (0.4, 0.1, 1.).\nWe need to write a function that determines if "),a("strong",[t._v("p")]),t._v(" is inside or outside our sphere.\nThe easiest way to do this is to calculate the distance from our origin to the sphere, and subtract the size of the sphere we want to make.")]),t._v(" "),a("div",{staticClass:"language-glsl extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-glsl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("scene")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" size "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("distance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Because the origin is 0.0 for short we can just calculate the length of p and subtract our size;")]),t._v(" "),a("div",{staticClass:"language-glsl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-glsl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("scene")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("length")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Breaking down: sphere(p, 0.2).\nHere we're providing the currently pixel coordinate p and the size that we want to define our sphere.")]),t._v(" "),a("p",[t._v("Try change 0.2 to a smaller and larger value.\nNotice if you set the value to 1.0 it fills the entire space.")]),t._v(" "),a("h2",{attrs:{id:"coordinate-space"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-space"}},[t._v("#")]),t._v(" Coordinate space")]),t._v(" "),a("h2",{attrs:{id:"coloring-your-sculpture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coloring-your-sculpture"}},[t._v("#")]),t._v(" Coloring your sculpture")]),t._v(" "),a("p",[t._v("In "),a("strong",[t._v("shade")]),t._v(" we define how we want to shade in the color at each pixel.")]),t._v(" "),a("h2",{attrs:{id:"coloring-two-different-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coloring-two-different-objects"}},[t._v("#")]),t._v(" Coloring two different objects")]),t._v(" "),a("h2",{attrs:{id:"learning-glsl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#learning-glsl"}},[t._v("#")]),t._v(" "),a("a",{attrs:{name:"glsl"}}),t._v("Learning GLSL")]),t._v(" "),a("h2",{attrs:{id:"learning-raymarching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#learning-raymarching"}},[t._v("#")]),t._v(" Learning raymarching")])])}),[],!1,null,null,null);e.default=r.exports}}]);