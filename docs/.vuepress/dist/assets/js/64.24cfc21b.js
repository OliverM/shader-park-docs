(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{266:function(e,a,t){"use strict";t.r(a);var n=t(0),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("h2",{attrs:{id:"motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),t("p",[e._v("Functional representations provide a highly expressive medium for modeling and animation. The goal of this project is to provide a simple, batteries-included platform that makes it as")]),e._v(" "),t("h2",{attrs:{id:"distance-fields"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#distance-fields"}},[e._v("#")]),e._v(" Distance Fields")]),e._v(" "),t("p",[e._v("Distance fields (DFs) are a type of functional representation for defining a 3D model. Deriving the DF of an arbitrary surface in general is a complex problem. However by considering some basic examples we can an intuition for modeling with DFs.")]),e._v(" "),t("h3",{attrs:{id:"coordinate-systems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-systems"}},[e._v("#")]),e._v(" Coordinate Systems")]),e._v(" "),t("p",[e._v("Spherical")]),e._v(" "),t("h3",{attrs:{id:"preserving-operations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#preserving-operations"}},[e._v("#")]),e._v(" Preserving operations")]),e._v(" "),t("p",[e._v("Translation\nRotation\nReflection")]),e._v(" "),t("h3",{attrs:{id:"non-preserving-operations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#non-preserving-operations"}},[e._v("#")]),e._v(" Non-Preserving operations")]),e._v(" "),t("p",[e._v("Any abritrary distortion")]),e._v(" "),t("h2",{attrs:{id:"the-sphere-tracing-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-sphere-tracing-algorithm"}},[e._v("#")]),e._v(" The Sphere-tracing algorithm")]),e._v(" "),t("h2",{attrs:{id:"sources"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sources"}},[e._v("#")]),e._v(" Sources")]),e._v(" "),t("p",[e._v("Much of the math and code in this page is based on\nIQ articles\nJamie wong")]),e._v(" "),t("h2",{attrs:{id:"glsl-opengl-shading-language"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glsl-opengl-shading-language"}},[e._v("#")]),e._v(" GLSL (OpenGL Shading Language)")]),e._v(" "),t("p",[e._v("GLSL a small language (essentially C without pointers) with built-in functions and data types for working with vectors and common maths. It is designed to run very efficiently on a graphics processor, even from within a web page. Graphics processors are capable of performing calculations at an amazing speed. In just a few minutes of interactive modeling on this site, your program in distanceToSurface can easily be executed over 100 billion times.")]),e._v(" "),t("p",[e._v("Some built in types:\nvec2\nvec3\nvec4\nmat2\nmat3\nmat4")]),e._v(" "),t("p",[e._v("Some built in functions:\nfloat length(vec v)\nfloat distance(vec v1,vec v2)\nvec normalize(vec v)\npow\nexp\nsqrt\nabs\nTrig - sin, cos, tan, atan, acos, asin...")]),e._v(" "),t("p",[e._v("A full list of built-in functions can be found at: [url]")]),e._v(" "),t("h2",{attrs:{id:"further-reading-and-resources"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#further-reading-and-resources"}},[e._v("#")]),e._v(" Further reading and resources")]),e._v(" "),t("p",[e._v("IQs articles\nshadertoy\nCurv")])])}),[],!1,null,null,null);a.default=s.exports}}]);